/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 0.1.0 from webgme on Thu Dec 17 2015 14:41:36 GMT-0600 (CST).
 */

import _ = require("underscore");
import nodePropertyNames = require("js/NodePropertyNames");
import GMEConcepts = require("js/Utils/GMEConcepts");
import registryKeys = require("js/RegistryKeys");
import PreferencesHelper = require("js/Utils/PreferencesHelper");

import { CytoscapeConstants } from "./constants/CytoscapeConstants";
import { GmeConstants, LineStyleArrows, LineStylePatterns } from "./constants/GmeConstants";
import { CytoscapeWidget } from "visualizers/widgets/cytoscape/CytoscapeWidget";
import "WebGMEGlobal";

/*
define(["js/constraints",
    "js/Utils/GMEConcepts",
    "js/NodePropertyNames",
    "js/RegistryKeys",
    "js/Utils/PreferencesHelper",
    "./cytoscape.constratints",
    "cytoscape"
], function (GmeConstants,
    GMEConcepts,
    nodePropertyNames,
    registryKeys,
    PreferencesHelper,
    CytoscapeConstants,
    cytoscape) {
*/

interface TerritoryRule {
    children: number;
}


export interface CytoscapeControlOptions {
    logger: Core.GmeLogger;
    client: GME.Client;
    widget: CytoscapeWidget;
};

export class ToolbarItems {
    constructor() {
        this.items = new Map<string, Toolbar.ToolbarItem>();
    }
    items: Map<string, Toolbar.ToolbarItem>;

    btnModelHierarchyUp: Toolbar.ToolbarButton;
    beginSeparator: Toolbar.ToolbarSeparator;
    ddbtnConnectionArrowStart: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionPattern: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionArrowEnd: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionLineWidth: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionLineType: Toolbar.ToolbarDropDownButton;

    cpFillColor: Toolbar.ToolbarColorPicker;
    cpTextColor: Toolbar.ToolbarColorPicker;
}

export class CytoscapeControl {

    private _logger: Core.GmeLogger;
    private _client: any;
    private _widget: CytoscapeWidget;
    private _currentNodeId: string | null;
    private _currentNodeParentId: string | undefined;
    public eventQueue: GME.Event[][];

    private _GMEModels: any[];
    private _GMEConnections: any[];

    private _GmeID2ComponentID: Dictionary<any>;
    private _ComponentID2GmeID: Dictionary<any>;

    private _GMEID2Subcomponent: Dictionary<any>;
    private _Subcomponent2GMEID: Dictionary<any>;

    private _delayedConnections: any[];
    private _delayedPointingObjects: any[];

    private _territoryId: TerritoryRule;
    private _thisPatterns: Dictionary<TerritoryRule>;
    private _toolbarItems: ToolbarItems;

    private _notifyPackage: Dictionary<any>;
    private _toolbarInitialized = false;

    private ___SLOW_CONN: boolean = false;

    constructor(options: CytoscapeControlOptions) {

        this._logger = options.logger.fork("Control");

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._widget._control = this;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;
        this.eventQueue = [];

        this._initWidgetEventHandlers();

        this._logger.debug("ctor finished");
    };

    _initWidgetEventHandlers = () => {
        this._widget.onNodeClick = function (id) {
            // Change the current active object
            let state = WebGMEGlobal.State;
            if (typeof state === "undefined") { return; }
            state.registerActiveObject(id);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    selectedObjectChanged = (nodeId: string) => {
        let desc = this._getObjectDescriptor(nodeId);

        this._logger.debug(`activeObject nodeId "${nodeId}"`);

        // reinitialize cy data in widget
        this._widget._cy.remove("node");
        this._widget._cy.remove("edge");

        // clean up local hash map
        this._GMEModels = [];
        this._GMEConnections = [];

        this._GmeID2ComponentID = {};
        this._ComponentID2GmeID = {};

        this._GMEID2Subcomponent = {};
        this._Subcomponent2GMEID = {};

        this._delayedConnections = [];
        this._delayedPointingObjects = [];

        // Remove current territory patterns
        if (this._currentNodeId) {
            this._client.removeUI(this._territoryId);
        }

        this._currentNodeId = nodeId;
        this._currentNodeParentId = undefined;

        if (this._currentNodeId ||
            this._currentNodeId === GmeConstants.PROJECT_ROOT_ID) {

            // Put new node"s info into territory rules
            this._thisPatterns = {};
            this._thisPatterns[nodeId] = {
                children: 0
            }; // Territory "rule"

            if (typeof desc.name === "string") {
                this._widget.setTitle(desc.name);
            }
            // save active node (current active container)
            this._widget.setActiveNode(nodeId);

            if (desc.parentId || desc.parentId === GmeConstants.PROJECT_ROOT_ID) {
                this._toolbarItems.btnModelHierarchyUp.show();
            } else {
                this._toolbarItems.btnModelHierarchyUp.hide();
            }

            this._currentNodeParentId = desc.parentId;

            this._territoryId = this._client.addUI(this, (events: GME.Event[]) => {
                this._eventCallback(events);
            });

            // Update the territory
            this._client.updateTerritory(this._territoryId, this._thisPatterns);

            this._thisPatterns[nodeId] = {
                children: 1
            };
            this._client.updateTerritory(this._territoryId, this._thisPatterns);
        }
    };

    // This next function retrieves the relevant node information for the widget
    _getObjectDescriptor = (nodeId: Common.NodeId): GME.ObjectDescriptor => {
        let nodeObj = this._client.getNode(nodeId);

        if (!nodeObj) { return new GME.ObjectDescriptor; }

        let objDescriptor = new GME.ObjectDescriptor;

        objDescriptor.id = nodeObj.getId();
        objDescriptor.name = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
        objDescriptor.childrenIds = nodeObj.getChildrenIds();
        objDescriptor.childrenNum = (typeof objDescriptor.childrenIds === "undefined") ? 0 : objDescriptor.childrenIds.length;
        objDescriptor.parentId = nodeObj.getParentId();
        objDescriptor.isConnection = GMEConcepts.isConnection(nodeObj);
        // GMEConcepts can be helpful
        // objDescriptor.isConnection = Boolean(nodeObj.getPointer("src") && nodeObj.getPointer("dst"));
        objDescriptor.position = nodeObj.getRegistry(registryKeys.POSITION);
        if (objDescriptor.isConnection) {
            objDescriptor.source = nodeObj.getPointer("src");
            objDescriptor.target = nodeObj.getPointer("dst");
        }

        let pointers = nodeObj.getPointerNames();
        for (let i = 0; i < pointers.length; ++i) {
            if (((pointers[i] !== "src" && pointers[i] !== "dst") || !objDescriptor.isConnection)
                && pointers[i] !== "base") {
                if (!objDescriptor.pointers) {
                    objDescriptor.pointers = {};
                }
                objDescriptor.pointers[pointers[i]] = nodeObj.getPointer(pointers[i]);
            }
        }
        return objDescriptor;
    };

    _getCytoscapeData = (desc: GME.ObjectDescriptor) => {
        let data: any[] = [];
        if (desc) {

            if (desc.isConnection) {
                /***** this section is used to create hyper edges *****/

                if (desc.pointers) {
                    let x = desc.srcPos.x + desc.dstPos.x;
                    let y = desc.srcPos.y + desc.dstPos.y;
                    let n = 2;
                    for (let i in desc.pointers) {
                        if (!desc.pointers[i].to) { continue; }
                        if (!this._GmeID2ComponentID.hasOwnProperty(desc.pointers[i].to)) { continue; }
                        n++;
                        let pos = this._client.getNode(desc.pointers[i].to).getRegistry(registryKeys.POSITION);
                        x += pos.x;
                        y += pos.y;
                    }
                    data.push({
                        group: "nodes",
                        data: {
                            id: desc.id,
                            name: desc.name
                        },
                        position: {
                            x: x / n,
                            y: y / n
                        }
                    });

                    data.push({
                        group: "edges",
                        data: {
                            id: `${desc.id}src`,
                            name: "src",
                            source: desc.id,
                            target: desc.srcObjId
                        }
                    });

                    data.push({
                        group: "edges",
                        data: {
                            id: `${desc.id}dst`,
                            name: "dst",
                            source: desc.id,
                            target: desc.dstObjId
                        }
                    });
                } else {
                    data.push({
                        group: "edges",
                        data: {
                            id: desc.id,
                            name: desc.name,
                            source: desc.srcObjId,
                            target: desc.dstObjId
                        }
                    });
                }

                /*****/


                // data.push({
                //     group: "edges",
                //     data: { id: desc.id, source: desc.source.to, target: desc.target.to}
                // });
            } else {
                data.push({
                    group: "nodes",
                    data: {
                        id: desc.id,
                        name: desc.name
                    },
                    position: desc.position
                });

                // for (let i = 0; i < desc.childrenIds.length; ++i) {
                //     data.push({
                //         group: "nodes",
                //         data: {
                //             id: desc.childrenIds[i],
                //             parent: desc.id
                //         }
                //     });
                // }
            }

            if (desc.pointers) {
                for (let i in desc.pointers) {
                    if (desc.pointers[i].to) {
                        data.push({
                            group: "edges",
                            data: {
                                name: i,
                                id: `${desc.id}${i}`,
                                source: desc.id,
                                target: desc.pointers[i].to
                            }
                        });
                    }
                }
            }
        }
        return data;
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    _eventCallback = (events: GME.Event[]) => {
        let i = events ? events.length : 0;

        this._logger.debug(`_eventCallback "${i}" items`);

        if (i > 0) {
            this.eventQueue.push(events);
            this.processNextInQueue();
        }

        this._logger.debug(`_eventCallback "${events.length}" items - DONE`);
    };

    processNextInQueue = (): void => {
        if (this.eventQueue.length < 1) { return; }

        let batch = this.eventQueue.pop();
        if (typeof batch === "undefined") { return; }
        for (let event of batch.reverse()) {
            let desc = this._getObjectDescriptor(event.eid);
            if (event.etype !== GmeConstants.TERRITORY_EVENT_LOAD) {
                event.desc = desc;
                continue;
            }
            if (event.etype !== GmeConstants.TERRITORY_EVENT_UPDATE) {
                event.desc = desc;
                continue;
            }
        }
        this._dispatchEvents(batch);
    }

    _dispatchEvents = (events: GME.Event[]) => {
        let i = events.length;
        let territoryChanged = false;
        let MAX_VAL = 999999999;

        this._logger.debug(`_dispatchEvents ${events[0].etype}`);
        events.shift();

        this._logger.debug(`_dispatchEvents "${i}" items`);

        /********** ORDER EVENTS BASED ON DEPENDENCY ************/
        /** 1: items first, no dependency **/
        /** 2: connections second, dependency if a connection is connected to an other connection **/
        let orderedItemEvents: GME.Event[] = [];
        let orderedConnectionEvents: GME.Event[] = [];

        if (this._delayedConnections && this._delayedConnections.length > 0) {
            /*this._logger.warn(`_delayedConnections: ${this._delayedConnections.length}` );*/
            for (let i = 0; i < this._delayedConnections.length; i += 1) {
                orderedConnectionEvents.push({
                    etype: GmeConstants.TERRITORY_EVENT_LOAD,
                    eid: this._delayedConnections[i],
                    desc: this._getObjectDescriptor(this._delayedConnections[i])
                });
            }
        }
        if (this._delayedPointingObjects && this._delayedPointingObjects.length > 0) {
            for (i = 0; i < this._delayedPointingObjects.length; i += 1) {
                orderedItemEvents.push({
                    etype: GmeConstants.TERRITORY_EVENT_LOAD,
                    eid: this._delayedPointingObjects[i],
                    desc: this._getObjectDescriptor(this._delayedPointingObjects[i])
                });
            }
        }

        this._delayedConnections = [];
        this._delayedPointingObjects = [];

        let unloadEvents: GME.Event[] = [];
        i = events.length;
        while (i--) {
            let e: GME.Event = events[i];

            if (e.etype === GmeConstants.TERRITORY_EVENT_UPDATE) {
                unloadEvents.push(e);
                continue;
            }
            if (typeof e.desc === "undefined") {
                continue;
            }
            if (e.desc.isConnection) {
                if (e.desc.parentId === this._currentNodeId) {
                    // check to see if SRC and DST is another connection
                    // if so, put this guy AFTER them
                    let srcGMEID = e.desc.source;
                    let dstGMEID = e.desc.target;
                    let srcConnIdx = -1;
                    let dstConnIdx = -1;
                    let j = orderedConnectionEvents.length;
                    while (j--) {
                        let ce = orderedConnectionEvents[j];
                        if (ce.id === srcGMEID || ce.id === dstGMEID) {
                            srcConnIdx = j;
                        }

                        if (srcConnIdx !== -1 && dstConnIdx !== -1) {
                            break;
                        }
                    }

                    let insertIdxAfter = Math.max(srcConnIdx, dstConnIdx);

                    // check to see if this guy is a DEPENDENT of any 
                    // already processed CONNECTION insert BEFORE THEM
                    let depSrcConnIdx = MAX_VAL;
                    let depDstConnIdx = MAX_VAL;
                    j = orderedConnectionEvents.length;
                    while (j--) {
                        let ce = orderedConnectionEvents[j];
                        if (typeof ce.desc === "undefined") { continue; }

                        if (e.desc.id === ce.desc.source) {
                            depSrcConnIdx = j;
                        } else if (e.desc.id === ce.desc.target) {
                            depDstConnIdx = j;
                        }

                        if (depSrcConnIdx !== MAX_VAL && depDstConnIdx !== MAX_VAL) {
                            break;
                        }
                    }

                    let insertIdxBefore = Math.min(depSrcConnIdx, depDstConnIdx);
                    if (insertIdxAfter === -1 && insertIdxBefore === MAX_VAL) {
                        orderedConnectionEvents.push(e);
                    } else {
                        if (insertIdxAfter !== -1 &&
                            insertIdxBefore === MAX_VAL) {
                            orderedConnectionEvents.splice(insertIdxAfter + 1, 0, e);
                        } else if (insertIdxAfter === -1 &&
                            insertIdxBefore !== MAX_VAL) {
                            orderedConnectionEvents.splice(insertIdxBefore, 0, e);
                        } else if (insertIdxAfter !== -1 &&
                            insertIdxBefore !== MAX_VAL) {
                            orderedConnectionEvents.splice(insertIdxBefore, 0, e);
                        }
                    }
                } else {
                    orderedItemEvents.push(e);
                }
            } else if (!e.desc.isConnection) {
                orderedItemEvents.push(e);
            } else if (this._currentNodeId === e.eid) {
                orderedItemEvents.push(e);
            }

        }

        events = unloadEvents.concat(orderedItemEvents);
        i = events.length;

        this._notifyPackage = {};

        this._widget.beginUpdate();

        // items
        for (let i = 0; i < events.length; i += 1) {
            let e = events[i];
            switch (e.etype) {
                case GmeConstants.TERRITORY_EVENT_LOAD:
                    territoryChanged = this._onLoad(e.eid, e.desc) || territoryChanged;
                    break;
                case GmeConstants.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(e.eid, e.desc);
                    break;
                case GmeConstants.TERRITORY_EVENT_UNLOAD:
                    territoryChanged = this._onUnload(e.eid) || territoryChanged;
                    break;
            }
        }

        // connections
        events = orderedConnectionEvents;
        i = events.length;

        // items
        for (i = 0; i < events.length; i += 1) {
            let e = events[i];
            switch (e.etype) {
                case GmeConstants.TERRITORY_EVENT_LOAD:
                    this._onLoad(e.eid, e.desc);
                    break;
                case GmeConstants.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(e.eid, e.desc);
                    break;
                case GmeConstants.TERRITORY_EVENT_UNLOAD:
                    this._onUnload(e.eid);
                    break;
            }
        }

        this._widget.endUpdate();

        // update the territory
        if (territoryChanged) {
            // TODO: review this async here
            if (this.___SLOW_CONN === true) {
                setTimeout(() => {
                    this._logger.debug("Updating territory with ruleset from decorators: " +
                        JSON.stringify(this._thisPatterns));
                    this._client.updateTerritory(this._territoryId, this._thisPatterns);
                }, 2000);
            } else {
                this._logger.debug("Updating territory with ruleset from decorators: " +
                    JSON.stringify(this._thisPatterns));
                this._client.updateTerritory(this._territoryId, this._thisPatterns);
            }
        }

        // //check if firstload
        // if (this._firstLoad === true) {
        //     this._firstLoad = false;

        //     //check if there is active selection set in client
        //     var activeSelection = WebGMEGlobal.State.getActiveSelection();

        //     if (activeSelection && activeSelection.length > 0) {
        //         i = activeSelection.length;
        //         var gmeID;
        //         var ddSelection = [];
        //         while (i--) {
        //             //try to find each object present in the active selection mapped to DiagramDesigner element
        //             gmeID = activeSelection[i];

        //             if (this._GmeID2ComponentID[gmeID]) {
        //                 ddSelection = ddSelection.concat(this._GmeID2ComponentID[gmeID]);
        //             }
        //         }

        //         // this.designerCanvas.select(ddSelection);
        //     }
        // }

        this._logger.debug(`_dispatchEvents "${events.length}" items - DONE`);

        // continue processing event queue
        this.processNextInQueue();
    };

    _onLoad = (gmeID: string, objD: GME.ObjectDescriptor | undefined) => {
        if (typeof objD === "undefined") { return; }
        let territoryChanged = false;

        // component loaded
        // we are interested in the load of sub_components of the opened component
        if (this._currentNodeId !== gmeID) {
            if (objD) {
                if (objD.parentId === this._currentNodeId) {
                    let objDesc = _.extend({}, objD);
                    this._GmeID2ComponentID[gmeID] = [];

                    let pointersLoaded = this._areAllPointersLoaded(objDesc);

                    if (!objDesc.isConnection) {

                        if (pointersLoaded) {
                            this.createCyObject(objDesc);

                            this._GMEModels.push(gmeID);

                            objDesc.control = this;
                            objDesc.metaInfo = {};
                            objDesc.metaInfo[GmeConstants.GME_ID] = gmeID;
                            objDesc.preferencesHelper = PreferencesHelper.getPreferences();

                            this._GmeID2ComponentID[gmeID].push(gmeID);
                            this._ComponentID2GmeID[gmeID] = gmeID;
                        } else {
                            this._delayedPointingObjects.push(gmeID);
                        }

                    } else {

                        this._GMEConnections.push(gmeID);

                        let srcDst = this._getAllSourceDestinationPairsForConnection(objDesc.source.to, objDesc.target.to);
                        let sources = srcDst.sources;
                        let destinations = srcDst.destinations;

                        // guards 
                        // when the connection is present, but no valid endpoint on canvas
                        // preserve the connection
                        if (sources.length < 1) {
                            this._delayedConnections.push(gmeID);
                        } else if (destinations.length < 1) {
                            this._delayedConnections.push(gmeID);
                        } else if (!pointersLoaded) {
                            this._delayedConnections.push(gmeID);
                        } else {
                            for (let source of sources.reverse()) {
                                for (let destination of destinations.reverse()) {
                                    objDesc.srcObjId = source.objId;
                                    objDesc.srcSubCompId = source.subCompId;
                                    objDesc.dstObjId = destination.objId;
                                    objDesc.dstSubCompId = destination.subCompId;
                                    objDesc.reconnectable = true;
                                    objDesc.editable = true;

                                    objDesc.srcPos = this._client.getNode(objDesc.srcObjId).getRegistry(registryKeys.POSITION);
                                    objDesc.dstPos = this._client.getNode(objDesc.dstObjId).getRegistry(registryKeys.POSITION);


                                    delete objDesc.source;
                                    delete objDesc.target;

                                    this.createCyObject(objDesc);

                                    this._logger.debug(`Connection: ${gmeID} for GME object: ${objDesc.id}`);

                                    this._GmeID2ComponentID[gmeID].push(gmeID);
                                    this._ComponentID2GmeID[gmeID] = gmeID;
                                }
                            }
                        }
                    }
                } else {
                    // supposed to be the grandchild of the currently open node
                    // --> load of port
                    /* 
                     if(this._GMEModels.indexOf(objD.parentId) !== -1){
                     this._onUpdate(objD.parentId,this._getObjectDescriptor(objD.parentId));
                     }
                    */
                    this._checkComponentDependency(gmeID, GmeConstants.TERRITORY_EVENT_LOAD);
                }
            }
        } else {
            // currently opened node
            //  this._updateSheetName(objD.name);
            //  this._updateAspects();
        }

        return territoryChanged;
    };

    _checkComponentDependency = (gmeID: string, action: string): void => {
        this._logger.error(`check-component-dependency not implemented ${gmeID} ${action}`);
        return;
    }

    _getAllSourceDestinationPairsForConnection =
    (GMESrcId: string, GMEDstId: string): GMEConcepts.ConnectionCollectionPair => {

        let sources: GMEConcepts.ComposeChain[] = [];
        let destinations: GMEConcepts.ComposeChain[] = [];

        if (this._GmeID2ComponentID.hasOwnProperty(GMESrcId)) {
            // src is a DesignerItem
            for (let compId of this._GmeID2ComponentID[GMESrcId].reverse()) {
                sources.push({
                    objId: compId,
                    subCompId: undefined
                });
            }
        } else {
            // src is not a DesignerItem
            // must be a sub_components somewhere, find the corresponding designerItem
            if (this._GMEID2Subcomponent && this._GMEID2Subcomponent.hasOwnProperty(GMESrcId)) {
                for (let i in this._GMEID2Subcomponent[GMESrcId]) {
                    if (this._GMEID2Subcomponent[GMESrcId].hasOwnProperty(i)) {
                        sources.push({
                            objId: i,
                            subCompId: this._GMEID2Subcomponent[GMESrcId][i]
                        });
                    }
                }
            }
        }

        if (this._GmeID2ComponentID.hasOwnProperty(GMEDstId)) {
            for (let obj of this._GmeID2ComponentID[GMEDstId].reverse()) {
                destinations.push({
                    objId: obj,
                    subCompId: undefined
                });
            }
        } else {
            // dst is not a DesignerItem
            // must be a sub_components somewhere, find the corresponding designerItem
            if (this._GMEID2Subcomponent && this._GMEID2Subcomponent.hasOwnProperty(GMEDstId)) {
                for (let i in this._GMEID2Subcomponent[GMEDstId]) {
                    if (this._GMEID2Subcomponent[GMEDstId].hasOwnProperty(i)) {
                        destinations.push({
                            objId: i,
                            subCompId: this._GMEID2Subcomponent[GMEDstId][i]
                        });
                    }
                }
            }
        }

        return {
            sources: sources,
            destinations: destinations
        };
    };

    _areAllPointersLoaded = (desc: GME.ObjectDescriptor) => {
        let pointers = desc.pointers;
        if (!pointers) {
            return true;
        }
        let len = 0;
        for (let i in pointers) {
            if (!pointers[i].to || this._GmeID2ComponentID.hasOwnProperty(pointers[i].to)) {
                ++len;
            }
        }
        return len === Object.keys(desc.pointers).length;
    }

    createCyObject = (desc: GME.ObjectDescriptor) => {
        let cyData = this._getCytoscapeData(desc);
        this._widget.addNode(cyData);
    };


    // _onLoad = function (gmeId) {
    //     if (this._currentNodeId !== gmeId) {
    //         var description = this._getObjectDescriptor(gmeId);
    //         var cyData = this._getCytoscapeData(description);
    //         this._widget.addNode(cyData);
    //     }
    // };


    _onUpdate(gmeId: string, desc?: GME.ObjectDescriptor): void {
        if (typeof desc === "undefined") {
            let description = this._getObjectDescriptor(gmeId);
            this._widget.updateNode(description);
            return;
        }
        this._widget.updateNode(desc);
    };

    _onUnload = (gmeId: string) => {
        this._widget.removeNode(gmeId);
    };

    _stateActiveObjectChanged = (_model: any, activeObjectId: string) => {
        this.selectedObjectChanged(activeObjectId);
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    destroy = () => {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    _attachClientEventListeners = () => {
        this._detachClientEventListeners();
        let state = WebGMEGlobal.State;
        if (typeof state === "undefined") { return; }
        state.on(`change: ${GmeConstants.STATE_ACTIVE_OBJECT}`, this._stateActiveObjectChanged, this);
    };

    _detachClientEventListeners = () => {
        let state = WebGMEGlobal.State;
        if (typeof state === "undefined") { return; }
        state.off(`change: ${GmeConstants.STATE_ACTIVE_OBJECT}`, this._stateActiveObjectChanged);
    };

    onActivate = () => {
        this._attachClientEventListeners();
        this._displayToolbarItems();
    };

    onDeactivate = () => {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    _displayToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    _hideToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.hide();
            }
        }
    };

    _removeToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.destroy();
            }
        }
    };

    _setCyObjectProperty = (params: { [name: string]: string }) => {
        if (this._widget._selectedCyObject) {
            for (let p in params) {
                let cyObj = this._widget._selectedCyObject;
                if (typeof cyObj === "string") { continue; }
                cyObj.style(p, params[p]);
            }
        }
    };


    _initializeToolbar = (): void => {
        let toolBar = WebGMEGlobal.Toolbar;
        if (typeof toolBar === "undefined") { return; }

        let btnIconBase = $("<i/>");
        this._toolbarItems = new ToolbarItems();

        this._toolbarItems.beginSeparator = toolBar.addSeparator();

        /************** Go to hierarchical parent button ****************/
        this._toolbarItems.btnModelHierarchyUp = toolBar.addButton({
            title: "Go to parent",
            icon: "glyphicon glyphicon-circle-arrow-up",
            clickFn: ( /*data*/): void => {
                let state = WebGMEGlobal.State;
                if (typeof state === "undefined") { return; }
                if (typeof this._currentNodeParentId === "undefined") { return; }
                state.registerActiveObject(this._currentNodeParentId);
            }
        });
        this._toolbarItems.btnModelHierarchyUp.hide();

        this._toolbarItems.ddbtnConnectionArrowStart = toolBar.addDropDownButton({
            title: "Line start marker",
            icon: "glyphicon glyphicon-arrow-left",
            menuClass: "no-min-width"
        });
        this._toolbarItems.ddbtnConnectionPattern = toolBar.addDropDownButton({
            title: "Line pattern",
            icon: "glyphicon glyphicon-minus",
            menuClass: "no-min-width"
        });
        this._toolbarItems.ddbtnConnectionArrowEnd = toolBar.addDropDownButton({
            title: "Line end marker",
            icon: "glyphicon glyphicon-arrow-right",
            menuClass: "no-min-width"
        });

        this._toolbarItems.ddbtnConnectionLineWidth = toolBar.addDropDownButton({
            title: "Line width",
            icon: btnIconBase.clone().addClass("gme icon-gme_lines"),
            menuClass: "no-min-width"
        });

        this._toolbarItems.ddbtnConnectionLineType = toolBar.addDropDownButton({
            title: "Line type",
            icon: btnIconBase.clone().addClass("gme  icon-gme_curvy-line"),
            menuClass: "no-min-width"
        });

        let createArrowMenuItem = (arrowType: string, isEnd: boolean) => {
            let size = arrowType === LineStyleArrows.NONE ? "" : "-xwide-xlong";
            let startArrow = isEnd ? null : `${arrowType}${size}`;
            let startArrowCy = isEnd ? null : (<any>LineStyleArrows)[arrowType];
            let endArrow = isEnd ? `${arrowType}${size}` : null;
            let endArrowCy = isEnd ? (<any>LineStyleArrows)[arrowType] : null;

            return {
                title: arrowType,
                icon: this._createLineStyleMenuItem(null, null, null, startArrow, endArrow, null),
                data: <GMEConcepts.ConnectionStyle>{
                    endArrow: endArrowCy,
                    startArrow: startArrowCy
                },
                clickFn: (data: GMEConcepts.ConnectionStyle) => {
                    let p: Dictionary<string> = {};
                    if (data.endArrow) {
                        p[CytoscapeConstants.LINE_END_ARROW] = data.endArrow;
                    }
                    if (data.startArrow) {
                        p[CytoscapeConstants.LINE_START_ARROW] = data.startArrow;
                    }
                    this._setCyObjectProperty(p);
                }
            };
        };

        let createPatternMenuItem = (pattern: string) => {
            return {
                title: pattern,
                icon: this._createLineStyleMenuItem(null, null,
                    (<any>LineStylePatterns)[pattern], null, null, null),
                data: { pattern: pattern },
                clickFn: (data: { pattern: string }) => {
                    let p: Dictionary<string> = {};
                    p[CytoscapeConstants.LINE_PATTERN] =
                        (<any>LineStylePatterns)[data.pattern];
                    this._setCyObjectProperty(p);
                }
            };
        };

        for (let it in CytoscapeConstants.LINE_ARROWS) {
            if (CytoscapeConstants.LINE_ARROWS.hasOwnProperty(it)) {
                this._toolbarItems.ddbtnConnectionArrowStart.addButton(
                    createArrowMenuItem((<any>CytoscapeConstants.LINE_ARROWS)[it], false));

                this._toolbarItems.ddbtnConnectionArrowEnd.addButton(
                    createArrowMenuItem((<any>CytoscapeConstants.LINE_ARROWS)[it], true));
            }
        }

        for (let it in CytoscapeConstants.LINE_PATTERNS) {
            if (CytoscapeConstants.LINE_PATTERNS.hasOwnProperty(it)) {
                this._toolbarItems.ddbtnConnectionPattern.addButton(createPatternMenuItem(it));
            }
        }

        // fill linetype dropdown
        this._toolbarItems.ddbtnConnectionLineType.addButton({
            title: "Straight",
            icon: this._createLineStyleMenuItem(null, null, null, null, null, null),
            clickFn: (/*data*/) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LINE_TYPE] = CytoscapeConstants.LINE_TYPES.NONE;
                this._setCyObjectProperty(p);
            }
        });

        this._toolbarItems.ddbtnConnectionLineType.addButton({
            title: "Bezier",
            icon: this._createLineStyleMenuItem(null, null, null, null, null,
                CytoscapeConstants.LINE_TYPES.BEZIER),
            clickFn: (/*data*/) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LINE_TYPE] = CytoscapeConstants.LINE_TYPES.BEZIER;
                this._setCyObjectProperty(p);
            }
        });

        // fill linewidth dropdown
        let createWidthMenuItem = (width: number) => {
            return {
                title: width,
                icon: this._createLineStyleMenuItem(width, null,
                    CytoscapeConstants.LINE_PATTERNS.SOLID, null, null, null),
                data: { width: width },
                clickFn: (data: { width: string }) => {
                    let p: Dictionary<string> = {};
                    p[CytoscapeConstants.LINE_WIDTH] = data.width;
                    this._setCyObjectProperty(p);
                }
            };
        };

        for (let it = 1; it < 10; it += 1) {
            this._toolbarItems.ddbtnConnectionLineWidth.addButton(createWidthMenuItem(it));
        }

        this._toolbarItems.ddbtnConnectionArrowStart.enabled(false);
        this._toolbarItems.ddbtnConnectionPattern.enabled(false);
        this._toolbarItems.ddbtnConnectionArrowEnd.enabled(false);
        this._toolbarItems.ddbtnConnectionLineType.enabled(false);
        this._toolbarItems.ddbtnConnectionLineWidth.enabled(false);
        /************** END OF - VISUAL STYLE ARROWS *****************/


        // add fill color, text color, border color controls
        this._toolbarItems.cpFillColor = toolBar.addColorPicker({
            icon: "glyphicon glyphicon-tint",
            title: "Fill color",
            colorChangedFn: (color: string) => {
                let p: Dictionary<string> = {};
                let cyObj = this._widget._selectedCyObject;
                if (cyObj === null) {
                    this._logger.warn("selected cytoscape object is null");
                    return;
                }
                if (typeof cyObj === "string") {
                    this._logger.warn(`selected cytoscape object is ${cyObj}`);
                    return;
                }
                if (cyObj.isEdge()) {
                    p[CytoscapeConstants.LINE_COLOR] = color;
                    p[CytoscapeConstants.SOURCE_ARROW_COLOR] = color;
                    p[CytoscapeConstants.TARGET_ARROW_COLOR] = color;
                } else if (cyObj.isNode()) {
                    p[CytoscapeConstants.NODE_COLOR] = color;
                }
                this._setCyObjectProperty(p);
            }
        }
        );


        this._toolbarItems.cpTextColor = toolBar.addColorPicker({
            icon: "glyphicon glyphicon-font",
            title: "Text color",
            colorChangedFn: (color: string) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LABEL_COLOR] = color;
                this._setCyObjectProperty(p);
            }
        }
        );

        this._toolbarItems.cpFillColor.enabled(false);
        this._toolbarItems.cpTextColor.enabled(false);


        this._toolbarInitialized = true;
    };

    /**
     * uses http://dmitrybaranovskiy.github.io/raphael/
     */
    _createLineStyleMenuItem = (width: number | null,
        color: string | null, pattern: string | null, startArrow: string | null,
        endArrow: string | null, type: string | null) => {
        // jshint newcap:false
        let el = $("<div/>");
        let hSize = 50;
        let vSize = 20;

        width = width || 1;
        color = color || "#000000";
        pattern = pattern || CytoscapeConstants.LINE_PATTERNS.SOLID;
        startArrow = startArrow || CytoscapeConstants.LINE_ARROWS.NONE;
        endArrow = endArrow || CytoscapeConstants.LINE_ARROWS.NONE;
        type = (type || CytoscapeConstants.LINE_TYPES.NONE).toLowerCase();

        el.attr({ style: `height: ${vSize}px; width: ${hSize}px;` });
        /*
        let paper = Raphael(el[0], hSize, vSize);
        let bezierControlOffset = 10;
        
        if (type === CytoscapeConstants.LINE_TYPES.BEZIER) {
            
            path = paper.path(`M 5, ${Math.round(vSize / 2) + 0.5} C${5 + bezierControlOffset},` +
                `${Math.round(vSize / 2) + 0.5 - bezierControlOffset * 2} ${hSize - bezierControlOffset},` +
                `${Math.round(vSize / 2) + 0.5 + bezierControlOffset * 2} ${hSize - 5},` +
                `${Math.round(vSize / 2) + 0.5}`);
                
        } else {
            path = paper.path(`M 5,${Math.round(vSize / 2) + 0.5} L${hSize - 5},` +
                `${Math.round(vSize / 2) + 0.5}`);
        }
        

        path.attr({
            "arrow-start": startArrow,
            "arrow-end": endArrow,
            stroke: color,
            "stroke-width": width,
            "stroke-dasharray": pattern
        });
        */

        return el;
    };
}
