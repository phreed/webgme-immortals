/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 0.1.0 from webgme on Thu Dec 17 2015 14:41:36 GMT-0600 (CST).
 */

// import _ = require("underscore");
import Promise = require("bluebird");
import nodePropertyNames = require("js/NodePropertyNames");
import GMEConcepts = require("js/Utils/GMEConcepts");
import registryKeys = require("js/RegistryKeys");
import PreferencesHelper = require("js/Utils/PreferencesHelper");

import { CytoscapeConstants } from "./constants/CytoscapeConstants";
import { GmeConstants, LineStyleArrows, LineStylePatterns } from "./constants/GmeConstants";
import { CytoscapeWidget } from "visualizers/widgets/cytoscape/CytoscapeWidget";
import "WebGMEGlobal";



export interface CytoscapeControlOptions {
    logger: Core.GmeLogger;
    client: GME.Client;
    widget: CytoscapeWidget;
};

export class ToolbarItems {
    constructor() {
        this.items = new Map<string, Toolbar.ToolbarItem>();
    }
    items: Map<string, Toolbar.ToolbarItem>;

    btnModelHierarchyUp: Toolbar.ToolbarButton;
    beginSeparator: Toolbar.ToolbarSeparator;
    ddbtnConnectionArrowStart: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionPattern: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionArrowEnd: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionLineWidth: Toolbar.ToolbarDropDownButton;
    ddbtnConnectionLineType: Toolbar.ToolbarDropDownButton;

    cpFillColor: Toolbar.ToolbarColorPicker;
    cpTextColor: Toolbar.ToolbarColorPicker;
}


export class CytoscapeControl {

    private _logger: Core.GmeLogger;
    private _client: GME.Client;
    private _widget: CytoscapeWidget;
    private _currentNodeId: string | null;
    private _currentNodeParentId: string | undefined;
    public eventQueue: GME.Event[][];

    private _GMEModels: any[];
    private _GMEConnections: any[];

    private _GmeID2ComponentID: Dictionary<any>;
    private _ComponentID2GmeID: Dictionary<any>;

    private _GMEID2Subcomponent: Dictionary<any>;
    private _Subcomponent2GMEID: Dictionary<any>;

    /**
     * The objects pointing cannot be loaded until
     * the things which they point at.
     */
    private _delayedConnections: any[];
    private _delayedPointingObjects: any[];

    private _territoryId: GME.TerritoryId;
    private _patterns: Dictionary<GME.TerritoryPattern>;
    private _toolbarItems: ToolbarItems;

    private _notifyPackage: Dictionary<any>;
    private _toolbarInitialized = false;

    constructor(options: CytoscapeControlOptions) {

        this._logger = options.logger.fork("Control");

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._widget._control = this;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;
        this.eventQueue = [];

        this._initWidgetEventHandlers();

        this._logger.debug("ctor finished");
    };

    _initWidgetEventHandlers = () => {
        this._widget.onNodeClick = (id) => {
            // Change the current active object
            let state = WebGMEGlobal.State;
            if (typeof state === "undefined") { return; }
            state.registerActiveObject(id);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).

    selectedObjectChanged = (nodeId: string) => {
        let desc = this._getObjectDescriptor(nodeId);

        this._logger.debug(`activeObject nodeId "${nodeId}"`);

        // reinitialize cy data in widget
        this._widget._cy.remove("node");
        this._widget._cy.remove("edge");

        // clean up local dictionaries and arrays
        this._GMEModels = [];
        this._GMEConnections = [];

        this._GmeID2ComponentID = {};
        this._ComponentID2GmeID = {};

        this._GMEID2Subcomponent = {};
        this._Subcomponent2GMEID = {};

        this._delayedConnections = [];
        this._delayedPointingObjects = [];

        // Remove current territory patterns
        if (this._currentNodeId) {
            this._client.removeUI(this._territoryId);
        }

        this._currentNodeId = nodeId;
        this._currentNodeParentId = undefined; // desc.parentId

        // Test to see if the node-id looks like a path
        if (typeof this._currentNodeId !== "string") { return; }

        if (typeof desc.name === "string") {
            this._widget.setTitle(desc.name);
        }
        // save active node (current active container)
        this._widget.setActiveNode(nodeId);

        if (typeof desc.parentId !== "string") {
            this._toolbarItems.btnModelHierarchyUp.hide();
        } else if (desc.parentId === GmeConstants.PROJECT_ROOT_ID) {
            this._toolbarItems.btnModelHierarchyUp.show();
        } else {
            this._toolbarItems.btnModelHierarchyUp.hide();
        }

        this._currentNodeParentId = desc.parentId;

        this._territoryId = this._client.addUI(this, (events: GME.Event[]) => {
            if (!events) { return; }
            if (events.length < 1) { return; }

            this._logger.debug(`_eventCallback "${events.length}" items`);
            this.eventQueue.push(events);

            this.processNextInQueue();
        });

        // Update the territory
        // Put new node's info into territory pattern set
        this._patterns = {};
        this._patterns[nodeId] = { children: 1 };
        this._client.updateTerritory(this._territoryId, this._patterns);
    };

    // This next function retrieves the relevant node information for the widget
    _getObjectDescriptor = (nodeId: Common.NodeId): GME.ObjectDescriptor => {
        let nodeObj = this._client.getNode(nodeId);

        let objDescriptor: GME.ObjectDescriptor = {
            id: "",
            name: "",
            childrenIds: [],
            parentId: "",
            isConnection: false,
            childrenNum: 0,
            position: 0,
            source: "",
            target: "",
            pointers: {},
            srcPos: { x: 0, y: 0 },
            dstPos: { x: 0, y: 0 },
            srcObjId: "",
            dstObjId: "",
        };
        if (nodeId === "") { return objDescriptor; }
        if (!nodeObj) { return objDescriptor; }


        objDescriptor.id = nodeObj.getId();
        let outName = nodeObj.getAttribute(nodePropertyNames.Attributes.name);
        if (typeof outName === "string") {
            objDescriptor.name = outName;
        }
        objDescriptor.childrenIds = nodeObj.getChildrenIds();
        objDescriptor.childrenNum = (typeof objDescriptor.childrenIds === "undefined") ? 0 : objDescriptor.childrenIds.length;
        objDescriptor.parentId = nodeObj.getParentId();
        objDescriptor.isConnection = GMEConcepts.isConnection(nodeObj);
        // GMEConcepts can be helpful
        // objDescriptor.isConnection = Boolean(nodeObj.getPointer("src") && nodeObj.getPointer("dst"));
        objDescriptor.position = nodeObj.getRegistry(registryKeys.POSITION);
        if (objDescriptor.isConnection) {
            let outSourceId = nodeObj.getPointer("src");
            if (typeof outSourceId === "string") {
                objDescriptor.source = outSourceId;
            }
            let outTargetId = nodeObj.getPointer("dst");
            if (typeof outTargetId === "string") {
                objDescriptor.target = outTargetId;
            }
        }

        let pointers = nodeObj.getPointerNames();
        for (let i = 0; i < pointers.length; ++i) {
            if (((pointers[i] !== "src" && pointers[i] !== "dst") || !objDescriptor.isConnection)
                && pointers[i] !== "base") {
                if (!objDescriptor.pointers) {
                    objDescriptor.pointers = {};
                }
                objDescriptor.pointers[pointers[i]] = nodeObj.getPointer(pointers[i]);
            }
        }
        return objDescriptor;
    };

    _getCytoscapeData = (desc: GME.ObjectDescriptor): any[] => {
        let data: any[] = [];
        if (!desc) {
            return data;
        }
        if (desc.isConnection) {
            /***** this section is used to create hyper edges *****/

            if (desc.pointers) {
                let x = desc.srcPos.x + desc.dstPos.x;
                let y = desc.srcPos.y + desc.dstPos.y;
                let n = 2;
                for (let key in desc.pointers) {
                    if (desc.pointers.hasOwnProperty(key)) { continue; }
                    let pointer = desc.pointers[key];
                    if (!pointer.to) { continue; }
                    if (!this._GmeID2ComponentID.hasOwnProperty(pointer.to)) { continue; }

                    ++n;
                    let pos = this._client.getNode(pointer.to).getRegistry(registryKeys.POSITION);
                    x += pos.x;
                    y += pos.y;
                }
                data.push({
                    group: "nodes",
                    data: {
                        id: desc.id,
                        name: desc.name
                    },
                    position: {
                        x: x / n,
                        y: y / n
                    }
                });

                data.push({
                    group: "edges",
                    data: {
                        id: `${desc.id}src`,
                        name: "src",
                        source: desc.id,
                        target: desc.srcObjId
                    }
                });

                data.push({
                    group: "edges",
                    data: {
                        id: `${desc.id}dst`,
                        name: "dst",
                        source: desc.id,
                        target: desc.dstObjId
                    }
                });
            } else {
                data.push({
                    group: "edges",
                    data: {
                        id: desc.id,
                        name: desc.name,
                        source: desc.srcObjId,
                        target: desc.dstObjId
                    }
                });
            }

            /*****/


            // data.push({
            //     group: "edges",
            //     data: { id: desc.id, source: desc.source.to, target: desc.target.to}
            // });
        } else {
            data.push({
                group: "nodes",
                data: {
                    id: desc.id,
                    name: desc.name
                },
                position: desc.position
            });

            // for (let i = 0; i < desc.childrenIds.length; ++i) {
            //     data.push({
            //         group: "nodes",
            //         data: {
            //             id: desc.childrenIds[i],
            //             parent: desc.id
            //         }
            //     });
            // }
        }

        if (desc.pointers) {
            for (let i in desc.pointers) {
                if (desc.pointers[i].to) {
                    data.push({
                        group: "edges",
                        data: {
                            name: i,
                            id: `${desc.id}${i}`,
                            source: desc.id,
                            target: desc.pointers[i].to
                        }
                    });
                }
            }
        }
        return data;
    };

    /* * * * * * * * Node Event Handling * * * * * * * */


    /**
     * update the object descriptions of the events and dispatch them.
     */
    processNextInQueue = (): void => {
        try {
            if (this.eventQueue.length < 1) { return; }

            let batch = this.eventQueue.pop();
            if (typeof batch === "undefined") { return; }

            for (let ix = batch.length; ix--; ix) {
                let event = batch[ix];

                let desc = this._getObjectDescriptor(event.eid);
                if (event.etype === GmeConstants.TERRITORY_EVENT_LOAD) {
                    event.desc = desc;
                    continue;
                }
                if (event.etype === GmeConstants.TERRITORY_EVENT_UPDATE) {
                    event.desc = desc;
                    continue;
                }
            }
            this._dispatchEvents(batch);
        } catch (err) {
            this._logger.error(`problem processing queue`);
        }
    }

    _dispatchEvents = (events: GME.Event[]) => {
        let MAX_VAL = Number.MAX_VALUE;

        this._logger.debug(`_dispatchEvents ${events[0].etype}`);
        events.shift();

        this._logger.debug(`_dispatchEvents "${events.length}" items`);

        /********** ORDER EVENTS BASED ON DEPENDENCY ************/
        /** 1: items first, no dependency **/
        /** 2: connections second, dependency if a connection is connected to an other connection **/
        let orderedItemEvents: GME.Event[] = [];
        let orderedConnectionEvents: GME.Event[] = [];

        if (this._delayedConnections) {
            /*this._logger.warn(`_delayedConnections: ${this._delayedConnections.length}` );*/
            for (let connId of this._delayedConnections) {
                orderedConnectionEvents.push({
                    etype: GmeConstants.TERRITORY_EVENT_LOAD,
                    eid: connId,
                    desc: this._getObjectDescriptor(connId)
                });
            }
        }
        this._delayedConnections = [];

        if (this._delayedPointingObjects) {
            for (let ptrId of this._delayedPointingObjects) {
                orderedItemEvents.push({
                    etype: GmeConstants.TERRITORY_EVENT_LOAD,
                    eid: ptrId,
                    desc: this._getObjectDescriptor(ptrId)
                });
            }
        }
        this._delayedPointingObjects = [];

        let unloadEvents: GME.Event[] = [];

        for (let ix = events.length; ix--; ix) {
            let evt = events[ix];

            if (evt.etype === GmeConstants.TERRITORY_EVENT_UPDATE) {
                unloadEvents.push(evt);
                continue;
            }
            if (typeof evt.desc === "undefined") {
                continue;
            }
            if (!evt.desc.isConnection) {
                orderedItemEvents.push(evt);
                continue;
            }
            if (this._currentNodeId === evt.eid) {
                orderedItemEvents.push(evt);
                continue;
            }
            if (evt.desc.parentId !== this._currentNodeId) {
                orderedItemEvents.push(evt);
                continue;
            }

            // check to see if SRC and DST is another connection
            // if so, put this guy AFTER them
            let srcGMEID = evt.desc.source;
            let dstGMEID = evt.desc.target;
            let srcConnIdx = -1;
            let dstConnIdx = -1;
            for (let jx = orderedConnectionEvents.length; jx > -1; jx--) {
                let ce = orderedConnectionEvents[jx];
                if (ce.id === srcGMEID || ce.id === dstGMEID) {
                    srcConnIdx = jx;
                }

                if (srcConnIdx !== -1 && dstConnIdx !== -1) {
                    break;
                }
            }

            let insertIdxAfter = Math.max(srcConnIdx, dstConnIdx);

            // check to see if this guy is a DEPENDENT of any 
            // already processed CONNECTION insert BEFORE THEM
            let depSrcConnIdx = MAX_VAL;
            let depDstConnIdx = MAX_VAL;
            for (let jx = orderedConnectionEvents.length; jx > -1; jx--) {
                let ce = orderedConnectionEvents[jx];
                if (typeof ce.desc === "undefined") { continue; }

                if (evt.desc.id === ce.desc.source) {
                    depSrcConnIdx = jx;
                } else if (evt.desc.id === ce.desc.target) {
                    depDstConnIdx = jx;
                }

                if (depSrcConnIdx !== MAX_VAL && depDstConnIdx !== MAX_VAL) {
                    break;
                }
            }

            let insertIdxBefore = Math.min(depSrcConnIdx, depDstConnIdx);
            if (insertIdxAfter === -1 && insertIdxBefore === MAX_VAL) {
                orderedConnectionEvents.push(evt);
            } else {
                if (insertIdxAfter !== -1 &&
                    insertIdxBefore === MAX_VAL) {
                    orderedConnectionEvents.splice(insertIdxAfter + 1, 0, evt);
                } else if (insertIdxAfter === -1 &&
                    insertIdxBefore !== MAX_VAL) {
                    orderedConnectionEvents.splice(insertIdxBefore, 0, evt);
                } else if (insertIdxAfter !== -1 &&
                    insertIdxBefore !== MAX_VAL) {
                    orderedConnectionEvents.splice(insertIdxBefore, 0, evt);
                }
            }

        }
        this._notifyPackage = {};

        let territoryChanged = false;
        this._widget.beginUpdate();
        try {
            // 
            for (let evt of unloadEvents.concat(orderedItemEvents)) {
                switch (evt.etype) {
                    case GmeConstants.TERRITORY_EVENT_LOAD:
                        territoryChanged = this._onLoad(evt.eid, evt.desc) || territoryChanged;
                        break;
                    case GmeConstants.TERRITORY_EVENT_UPDATE:
                        this._onUpdate(evt.eid, evt.desc);
                        break;
                    case GmeConstants.TERRITORY_EVENT_UNLOAD:
                        territoryChanged = this._onUnload(evt.eid) || territoryChanged;
                        break;
                }
            }

            // 
            for (let evt of orderedConnectionEvents) {
                switch (evt.etype) {
                    case GmeConstants.TERRITORY_EVENT_LOAD:
                        this._onLoad(evt.eid, evt.desc);
                        break;
                    case GmeConstants.TERRITORY_EVENT_UPDATE:
                        this._onUpdate(evt.eid, evt.desc);
                        break;
                    case GmeConstants.TERRITORY_EVENT_UNLOAD:
                        this._onUnload(evt.eid);
                        break;
                }
            }
        } finally {
            this._widget.endUpdate();
        }

        // update the territory
        Promise
            .try(() => {
                if (territoryChanged) { return true; }
                if (this._delayedConnections.length > 0) { return true; }
                if (this._delayedPointingObjects.length > 0) { return true; }
                return false;
            })
            .then((territoryChanged: boolean) => {
                if (!territoryChanged) { return; }

                this._logger.warn("Updating territory with ruleset from decorators: " +
                    JSON.stringify(this._patterns));
                this._client.updateTerritory(this._territoryId, this._patterns);
            });
        // continue processing event queue
        this.processNextInQueue();
    };

    /**
     * an entity is a node with no pointers
     * realize that a node should not be added if...
     * return true if the object was seccessfully loaded (false otherwise)
     * True indicates that the territory changed.
     */
    _onLoadEntity
    = (gmeId: string, pointersLoaded: boolean, objDesc: GME.ObjectDescriptor): boolean => {
        if (!pointersLoaded) {
            this._delayedPointingObjects.push(gmeId);
            return false;
        }
        this._widget.addNode(this._getCytoscapeData(objDesc));

        this._GMEModels.push(gmeId);

        objDesc.control = this;
        objDesc.metaInfo = {};
        objDesc.metaInfo[GmeConstants.GME_ID] = gmeId;
        objDesc.preferencesHelper = PreferencesHelper.getPreferences();

        this._GmeID2ComponentID[gmeId].push(gmeId);
        this._ComponentID2GmeID[gmeId] = gmeId;

        return true;
    };

    /**
     * a connection is a node that has pointers
     * return true if the object was seccessfully loaded (false otherwise)
     * True indicates that the territory changed.
     */
    _onLoadConnection
    = (gmeId: string, pointersLoaded: boolean, objDesc: GME.ObjectDescriptor): boolean => {
        this._GMEConnections.push(gmeId);
        let srcDst = this._getAllSourceDestinationPairsForConnection(objDesc.source, objDesc.target);
        let sources = srcDst.sources;
        let destinations = srcDst.destinations;

        // guards 
        // when the connection is present, but no valid endpoint on canvas
        // preserve the connection
        if (sources.length < 1) {
            this._delayedConnections.push(gmeId);
            return false;
        }
        if (destinations.length < 1) {
            this._delayedConnections.push(gmeId);
            return false;
        }
        if (!pointersLoaded) {
            this._delayedConnections.push(gmeId);
            return false;
        }

        for (let ix = sources.length; ix--; ix) {
            let source = sources[ix];
            for (let jx = destinations.length; jx--; jx) {
                let destination = destinations[jx];

                objDesc.srcObjId = source.objId;
                objDesc.srcSubCompId = source.subCompId;
                objDesc.dstObjId = destination.objId;
                objDesc.dstSubCompId = destination.subCompId;
                objDesc.reconnectable = true;
                objDesc.editable = true;

                objDesc.srcPos = this._client.getNode(objDesc.srcObjId).getRegistry(registryKeys.POSITION);
                objDesc.dstPos = this._client.getNode(objDesc.dstObjId).getRegistry(registryKeys.POSITION);

                delete objDesc.source;
                delete objDesc.target;

                this._widget.addNode(this._getCytoscapeData(objDesc));

                this._logger.debug(`Connection: ${gmeId} for GME object: ${objDesc.id}`);

                this._GmeID2ComponentID[gmeId].push(gmeId);
                this._ComponentID2GmeID[gmeId] = gmeId;
            }
        }
        return true;
    }

    /** 
     * return true if the object was seccessfully loaded (false otherwise)
     * True indicates that the territory changed.
     */
    _onLoad
    = (gmeId: string, objDesc: GME.ObjectDescriptor | undefined): boolean => {
        if (typeof objDesc === "undefined") {
            return false;
        }

        // component loaded
        // we are interested in the load of sub_components of the opened component
        if (this._currentNodeId === gmeId) {
            // currently opened node
            //  this._updateSheetName(objD.name);
            //  this._updateAspects();
            return false;
        }

        if (!objDesc) {
            return false;
        }

        if (objDesc.parentId !== this._currentNodeId) {
            // supposed to be the grandchild of the currently open node
            // --> load of port
            /* 
             if(this._GMEModels.indexOf(objD.parentId) !== -1){
             this._onUpdate(objD.parentId,this._getObjectDescriptor(objD.parentId));
             }
            */
            this._checkComponentDependency(gmeId, GmeConstants.TERRITORY_EVENT_LOAD);
            return false;
        }


        this._GmeID2ComponentID[gmeId] = [];

        let pointersLoaded = this._areAllPointersLoaded(objDesc);

        if (objDesc.isConnection) {
            return this._onLoadConnection(gmeId, pointersLoaded, objDesc);
        } else {
            return this._onLoadEntity(gmeId, pointersLoaded, objDesc);
        }
    };

    _checkComponentDependency
    = (gmeID: string, action: string): void => {
        this._logger.error(`check-component-dependency not implemented ${gmeID} ${action}`);
        return;
    }

    _getAllSourceDestinationPairsForConnection
    = (GMESrcId: string, GMEDstId: string): GMEConcepts.ConnectionCollectionPair => {

        let sources: GMEConcepts.ComposeChain[] = [];
        let destinations: GMEConcepts.ComposeChain[] = [];

        if (this._GmeID2ComponentID.hasOwnProperty(GMESrcId)) {
            // src is a DesignerItem
            let compIds = this._GmeID2ComponentID[GMESrcId];
            for (let ix = compIds.length; ix--; ix) {
                let compId = compIds[ix];

                sources.push({
                    objId: compId,
                    subCompId: undefined
                });
            }
        } else {
            // src is not a DesignerItem
            // must be a sub_components somewhere, find the corresponding designerItem
            if (this._GMEID2Subcomponent && this._GMEID2Subcomponent.hasOwnProperty(GMESrcId)) {
                for (let i in this._GMEID2Subcomponent[GMESrcId]) {
                    if (this._GMEID2Subcomponent[GMESrcId].hasOwnProperty(i)) {
                        sources.push({
                            objId: i,
                            subCompId: this._GMEID2Subcomponent[GMESrcId][i]
                        });
                    }
                }
            }
        }

        if (this._GmeID2ComponentID.hasOwnProperty(GMEDstId)) {
            let compIds = this._GmeID2ComponentID[GMEDstId];
            for (let ix = compIds.length; ix--; ix) {
                let compId = compIds[ix];

                destinations.push({
                    objId: compId,
                    subCompId: undefined
                });
            }
        } else {
            // dst is not a DesignerItem
            // must be a sub_components somewhere, find the corresponding designerItem
            if (this._GMEID2Subcomponent && this._GMEID2Subcomponent.hasOwnProperty(GMEDstId)) {
                for (let ix in this._GMEID2Subcomponent[GMEDstId]) {
                    if (this._GMEID2Subcomponent[GMEDstId].hasOwnProperty(ix)) {
                        destinations.push({
                            objId: ix,
                            subCompId: this._GMEID2Subcomponent[GMEDstId][ix]
                        });
                    }
                }
            }
        }

        return {
            sources: sources,
            destinations: destinations
        };
    };

    /**
     * This function checks that all pointers that point 
     * point to something have been loaded. 
     */
    _areAllPointersLoaded = (desc: GME.ObjectDescriptor) => {
        let pointers = desc.pointers;
        if (!pointers) {
            return true;
        }
        for (let key in pointers) {
            if (!pointers.hasOwnProperty(key)) {
                return false;
            }
            let pointer = pointers[key];
            if (!pointer.to) {
                continue;
            }
            if (this._GmeID2ComponentID.hasOwnProperty(pointer.to)) {
                continue;
            }
            this._patterns[pointer.to] = { children: 0 };
            return false;
        }
        return true;
    }

    // _onLoad = (gmeId) => {
    //     if (this._currentNodeId !== gmeId) {
    //         var description = this._getObjectDescriptor(gmeId);
    //         var cyData = this._getCytoscapeData(description);
    //         this._widget.addNode(cyData);
    //     }
    // };

    _onUpdate(gmeId: string, desc?: GME.ObjectDescriptor): void {
        if (typeof desc === "undefined") {
            let description = this._getObjectDescriptor(gmeId);
            this._widget.updateNode(description);
            return;
        }
        this._widget.updateNode(desc);
    };

    _onUnload = (gmeId: string) => {
        this._widget.removeNode(gmeId);
    };

    _stateActiveObjectChanged = (_model: any, activeObjectId: string) => {
        this.selectedObjectChanged(activeObjectId);
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    destroy = () => {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    _attachClientEventListeners = () => {
        this._detachClientEventListeners();
        let state = WebGMEGlobal.State;
        if (typeof state === "undefined") { return; }
        state.on(`change: ${GmeConstants.STATE_ACTIVE_OBJECT}`, this._stateActiveObjectChanged, this);
    };

    _detachClientEventListeners = () => {
        let state = WebGMEGlobal.State;
        if (typeof state === "undefined") { return; }
        state.off(`change: ${GmeConstants.STATE_ACTIVE_OBJECT}`, this._stateActiveObjectChanged);
    };

    onActivate = () => {
        this._attachClientEventListeners();
        this._displayToolbarItems();
    };

    onDeactivate = () => {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    _displayToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    _hideToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.hide();
            }
        }
    };

    _removeToolbarItems = () => {

        if (this._toolbarInitialized === true) {
            for (let [, v] of this._toolbarItems.items) {
                v.destroy();
            }
        }
    };

    _setCyObjectProperty = (params: { [name: string]: string }) => {
        let cyObj = this._widget._selectedCyObject;
        if (!cyObj) { return; }
        if (typeof cyObj === "string") { return; }
        for (let p in params) {
            cyObj.style(p, params[p]);
        }
    };

    _initializeToolbar = (): void => {
        let toolBar = WebGMEGlobal.Toolbar;
        if (typeof toolBar === "undefined") { return; }

        let btnIconBase = $("<i/>");
        this._toolbarItems = new ToolbarItems();

        this._toolbarItems.beginSeparator = toolBar.addSeparator();

        /************** Go to hierarchical parent button ****************/
        this._toolbarItems.btnModelHierarchyUp = toolBar.addButton({
            title: "Go to parent",
            icon: "glyphicon glyphicon-circle-arrow-up",
            clickFn: ( /*data*/): void => {
                let state = WebGMEGlobal.State;
                if (typeof state === "undefined") { return; }
                if (typeof this._currentNodeParentId === "undefined") { return; }
                state.registerActiveObject(this._currentNodeParentId);
            }
        });
        this._toolbarItems.btnModelHierarchyUp.hide();

        this._toolbarItems.ddbtnConnectionArrowStart = toolBar.addDropDownButton({
            title: "Line start marker",
            icon: "glyphicon glyphicon-arrow-left",
            menuClass: "no-min-width"
        });
        this._toolbarItems.ddbtnConnectionPattern = toolBar.addDropDownButton({
            title: "Line pattern",
            icon: "glyphicon glyphicon-minus",
            menuClass: "no-min-width"
        });
        this._toolbarItems.ddbtnConnectionArrowEnd = toolBar.addDropDownButton({
            title: "Line end marker",
            icon: "glyphicon glyphicon-arrow-right",
            menuClass: "no-min-width"
        });

        this._toolbarItems.ddbtnConnectionLineWidth = toolBar.addDropDownButton({
            title: "Line width",
            icon: btnIconBase.clone().addClass("gme icon-gme_lines"),
            menuClass: "no-min-width"
        });

        this._toolbarItems.ddbtnConnectionLineType = toolBar.addDropDownButton({
            title: "Line type",
            icon: btnIconBase.clone().addClass("gme  icon-gme_curvy-line"),
            menuClass: "no-min-width"
        });

        let createArrowMenuItem = (arrowType: string, isEnd: boolean) => {
            let size = arrowType === LineStyleArrows.NONE ? "" : "-xwide-xlong";
            let startArrow = isEnd ? null : `${arrowType}${size}`;
            let startArrowCy = isEnd ? null : (<any>LineStyleArrows)[arrowType];
            let endArrow = isEnd ? `${arrowType}${size}` : null;
            let endArrowCy = isEnd ? (<any>LineStyleArrows)[arrowType] : null;

            return {
                title: arrowType,
                icon: this._createLineStyleMenuItem(null, null, null, startArrow, endArrow, null),
                data: <GMEConcepts.ConnectionStyle>{
                    endArrow: endArrowCy,
                    startArrow: startArrowCy
                },
                clickFn: (data: GMEConcepts.ConnectionStyle) => {
                    let p: Dictionary<string> = {};
                    if (data.endArrow) {
                        p[CytoscapeConstants.LINE_END_ARROW] = data.endArrow;
                    }
                    if (data.startArrow) {
                        p[CytoscapeConstants.LINE_START_ARROW] = data.startArrow;
                    }
                    this._setCyObjectProperty(p);
                }
            };
        };

        let createPatternMenuItem = (pattern: string) => {
            return {
                title: pattern,
                icon: this._createLineStyleMenuItem(null, null,
                    (<any>LineStylePatterns)[pattern], null, null, null),
                data: { pattern: pattern },
                clickFn: (data: { pattern: string }) => {
                    let p: Dictionary<string> = {};
                    p[CytoscapeConstants.LINE_PATTERN] =
                        (<any>LineStylePatterns)[data.pattern];
                    this._setCyObjectProperty(p);
                }
            };
        };

        for (let it in CytoscapeConstants.LINE_ARROWS) {
            if (CytoscapeConstants.LINE_ARROWS.hasOwnProperty(it)) {
                this._toolbarItems.ddbtnConnectionArrowStart.addButton(
                    createArrowMenuItem((<any>CytoscapeConstants.LINE_ARROWS)[it], false));

                this._toolbarItems.ddbtnConnectionArrowEnd.addButton(
                    createArrowMenuItem((<any>CytoscapeConstants.LINE_ARROWS)[it], true));
            }
        }

        for (let it in CytoscapeConstants.LINE_PATTERNS) {
            if (CytoscapeConstants.LINE_PATTERNS.hasOwnProperty(it)) {
                this._toolbarItems.ddbtnConnectionPattern.addButton(createPatternMenuItem(it));
            }
        }

        // fill linetype dropdown
        this._toolbarItems.ddbtnConnectionLineType.addButton({
            title: "Straight",
            icon: this._createLineStyleMenuItem(null, null, null, null, null, null),
            clickFn: (/*data*/) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LINE_TYPE] = CytoscapeConstants.LINE_TYPES.NONE;
                this._setCyObjectProperty(p);
            }
        });

        this._toolbarItems.ddbtnConnectionLineType.addButton({
            title: "Bezier",
            icon: this._createLineStyleMenuItem(null, null, null, null, null,
                CytoscapeConstants.LINE_TYPES.BEZIER),
            clickFn: (/*data*/) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LINE_TYPE] = CytoscapeConstants.LINE_TYPES.BEZIER;
                this._setCyObjectProperty(p);
            }
        });

        // fill linewidth dropdown
        let createWidthMenuItem = (width: number) => {
            return {
                title: width,
                icon: this._createLineStyleMenuItem(width, null,
                    CytoscapeConstants.LINE_PATTERNS.SOLID, null, null, null),
                data: { width: width },
                clickFn: (data: { width: string }) => {
                    let p: Dictionary<string> = {};
                    p[CytoscapeConstants.LINE_WIDTH] = data.width;
                    this._setCyObjectProperty(p);
                }
            };
        };

        for (let it = 1; it < 10; it += 1) {
            this._toolbarItems.ddbtnConnectionLineWidth.addButton(createWidthMenuItem(it));
        }

        this._toolbarItems.ddbtnConnectionArrowStart.enabled(false);
        this._toolbarItems.ddbtnConnectionPattern.enabled(false);
        this._toolbarItems.ddbtnConnectionArrowEnd.enabled(false);
        this._toolbarItems.ddbtnConnectionLineType.enabled(false);
        this._toolbarItems.ddbtnConnectionLineWidth.enabled(false);
        /************** END OF - VISUAL STYLE ARROWS *****************/


        // add fill color, text color, border color controls
        this._toolbarItems.cpFillColor = toolBar.addColorPicker({
            icon: "glyphicon glyphicon-tint",
            title: "Fill color",
            colorChangedFn: (color: string) => {
                let p: Dictionary<string> = {};
                let cyObj = this._widget._selectedCyObject;
                if (cyObj === null) {
                    this._logger.warn("selected cytoscape object is null");
                    return;
                }
                if (typeof cyObj === "string") {
                    this._logger.warn(`selected cytoscape object is ${cyObj}`);
                    return;
                }
                if (cyObj.isEdge()) {
                    p[CytoscapeConstants.LINE_COLOR] = color;
                    p[CytoscapeConstants.SOURCE_ARROW_COLOR] = color;
                    p[CytoscapeConstants.TARGET_ARROW_COLOR] = color;
                } else if (cyObj.isNode()) {
                    p[CytoscapeConstants.NODE_COLOR] = color;
                }
                this._setCyObjectProperty(p);
            }
        }
        );


        this._toolbarItems.cpTextColor = toolBar.addColorPicker({
            icon: "glyphicon glyphicon-font",
            title: "Text color",
            colorChangedFn: (color: string) => {
                let p: Dictionary<string> = {};
                p[CytoscapeConstants.LABEL_COLOR] = color;
                this._setCyObjectProperty(p);
            }
        }
        );

        this._toolbarItems.cpFillColor.enabled(false);
        this._toolbarItems.cpTextColor.enabled(false);


        this._toolbarInitialized = true;
    };

    /**
     * uses http://dmitrybaranovskiy.github.io/raphael/
     */
    _createLineStyleMenuItem = (width: number | null,
        color: string | null, pattern: string | null, startArrow: string | null,
        endArrow: string | null, type: string | null) => {
        // jshint newcap:false
        let el = $("<div/>");
        let hSize = 50;
        let vSize = 20;

        width = width || 1;
        color = color || "#000000";
        pattern = pattern || CytoscapeConstants.LINE_PATTERNS.SOLID;
        startArrow = startArrow || CytoscapeConstants.LINE_ARROWS.NONE;
        endArrow = endArrow || CytoscapeConstants.LINE_ARROWS.NONE;
        type = (type || CytoscapeConstants.LINE_TYPES.NONE).toLowerCase();

        el.attr({ style: `height: ${vSize}px; width: ${hSize}px;` });
        /*
        let paper = Raphael(el[0], hSize, vSize);
        let bezierControlOffset = 10;
        
        if (type === CytoscapeConstants.LINE_TYPES.BEZIER) {
            
            path = paper.path(`M 5, ${Math.round(vSize / 2) + 0.5} C${5 + bezierControlOffset},` +
                `${Math.round(vSize / 2) + 0.5 - bezierControlOffset * 2} ${hSize - bezierControlOffset},` +
                `${Math.round(vSize / 2) + 0.5 + bezierControlOffset * 2} ${hSize - 5},` +
                `${Math.round(vSize / 2) + 0.5}`);
                
        } else {
            path = paper.path(`M 5,${Math.round(vSize / 2) + 0.5} L${hSize - 5},` +
                `${Math.round(vSize / 2) + 0.5}`);
        }
        
     
        path.attr({
            "arrow-start": startArrow,
            "arrow-end": endArrow,
            stroke: color,
            "stroke-width": width,
            "stroke-dasharray": pattern
        });
        */

        return el;
    };
}
